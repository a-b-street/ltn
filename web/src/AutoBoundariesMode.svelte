<script lang="ts">
  import type { ExpressionSpecification } from "maplibre-gl";
  import {
    FillLayer,
    GeoJSON,
    hoverStateFilter,
    LineLayer,
    type LayerClickInfo,
  } from "svelte-maplibre";
  import { downloadGeneratedFile } from "svelte-utils";
  import { isLine, isPolygon } from "svelte-utils/map";
  import { SplitComponent } from "svelte-utils/top_bar_layout";
  import BackButton from "./BackButton.svelte";
  import { layerId, Link } from "./common";
  import { pickNeighbourhoodName } from "./common/pick_names";
  import { autosave, backend, editPerimeterRoads, mode } from "./stores";

  let gj = $backend!.renderAutoBoundaries();
  let minArea = 0;
  let removeNonRoad = true;

  function add(e: CustomEvent<LayerClickInfo>) {
    let name = pickNeighbourhoodName(
      $backend!,
      "What do you want to name the neighbourhood?",
      "",
    );
    if (!name) {
      return;
    }
    try {
      let feature = {
        type: "Feature" as const,
        // Omit waypoints and lazily fill them out.
        properties: {},
        // Trust generateId to make IDs in order
        geometry: gj.features[e.detail.features[0].id as number].geometry,
      };
      $backend!.setNeighbourhoodBoundary(name, feature);
      autosave();
      $backend!.setCurrentNeighbourhood(name, $editPerimeterRoads);
      $mode = {
        mode: "neighbourhood",
      };
    } catch (err) {
      console.log(err);
      window.alert(
        "Known georust bug hit, sorry. You may need to just refresh the page now.",
      );
    }
  }

  function download() {
    downloadGeneratedFile(
      "auto_boundaries.geojson",
      JSON.stringify(gj, null, "  "),
    );
  }

  function makeFilter(
    minArea: number,
    removeNonRoad: boolean,
  ): ExpressionSpecification {
    let x: ExpressionSpecification = [
      "all",
      isPolygon,
      [">=", ["get", "area_km2"], minArea],
    ];
    if (removeNonRoad) {
      x.push(["get", "touches_big_road"]);
    }
    return x;
  }
</script>

<SplitComponent>
  <div slot="top">
    <nav aria-label="breadcrumb">
      <ul>
        <li>
          <Link on:click={() => ($mode = { mode: "title", firstLoad: false })}>
            Choose project
          </Link>
        </li>
        <li>
          <Link on:click={() => ($mode = { mode: "pick-neighbourhood" })}>
            Pick neighbourhood
          </Link>
        </li>
        <li>Use an auto-generated boundary</li>
      </ul>
    </nav>
  </div>

  <div slot="sidebar">
    <BackButton on:click={() => ($mode = { mode: "pick-neighbourhood" })} />

    <p>
      Click an area to use it as a neighbourhood. These are generated by finding
      roads, railways, and water that form severances. There are many bugs; this
      is experimental. The colors are arbitrary, just to distinguish better.
    </p>

    <button class="secondary" on:click={download}>Export to GeoJSON</button>

    <label>
      Minimum area (kmÂ²)
      <input type="number" bind:value={minArea} min="0" max="1" step="0.01" />
    </label>

    <label>
      <input type="checkbox" bind:checked={removeNonRoad} />
      Remove areas not touching a big road
    </label>
  </div>

  <div slot="map">
    <GeoJSON data={gj} generateId>
      <FillLayer
        {...layerId("auto-boundaries-areas")}
        filter={makeFilter(minArea, removeNonRoad)}
        manageHoverState
        paint={{
          "fill-color": [
            "match",
            ["%", ["id"], 5],
            0,
            "blue",
            1,
            "yellow",
            2,
            "green",
            3,
            "purple",
            4,
            "orange",
            "black",
          ],
          "fill-opacity": hoverStateFilter(0.3, 0.7),
        }}
        on:click={add}
        hoverCursor="pointer"
      />

      <LineLayer
        {...layerId("auto-boundaries-severances")}
        filter={isLine}
        manageHoverState
        paint={{
          "line-color": hoverStateFilter("black", "red"),
          "line-width": 3,
        }}
      />
    </GeoJSON>
  </div>
</SplitComponent>
