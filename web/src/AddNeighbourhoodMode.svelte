<script lang="ts">
  import type { Feature, FeatureCollection, Polygon } from "geojson";
  import { Trash2 } from "lucide-svelte";
  import type { DataDrivenPropertyValueSpecification } from "maplibre-gl";
  import { onMount } from "svelte";
  import {
    FillLayer,
    GeoJSON,
    hoverStateFilter,
    LineLayer,
    type LayerClickInfo,
  } from "svelte-maplibre";
  import { downloadGeneratedFile, Loading, notNull } from "svelte-utils";
  import { emptyGeojson, Popup } from "svelte-utils/map";
  import { SplitComponent } from "svelte-utils/top_bar_layout";
  import BackButton from "./BackButton.svelte";
  import { layerId, ModeLink, pageTitle, prettyPrintPercent } from "./common";
  import AreaControls from "./common/draw_area/AreaControls.svelte";
  import { type Waypoint } from "./common/draw_area/stores";
  import NeighbourhoodBoundarySummary from "./common/NeighbourhoodBoundarySummary.svelte";
  import { pickNeighbourhoodName } from "./common/pick_names";
  import {
    prioritizationFillColor,
    PrioritizationSelect,
    type Prioritization,
  } from "./prioritization";
  import {
    appFocus,
    backend,
    currentProjectID,
    map,
    mode,
    projectStorage,
    saveCurrentProject,
    zoomToDefault,
  } from "./stores";
  import type { GeneratedBoundaryFeature } from "./wasm";

  let loading = "Generating severance boundaries...";
  let generatedBoundaries: FeatureCollection<
    GeneratedBoundaryFeature["geometry"],
    GeneratedBoundaryFeature["properties"]
  > = emptyGeojson() as any;

  let addMode: "choose-area" | "draw-area" = "choose-area";

  // Choosing area from autogenerated boundaries
  let selectedPrioritization: Prioritization = "none";
  let selectedBoundary: GeneratedBoundaryFeature | null = null;
  let selectedBoundaries: Map<number, GeneratedBoundaryFeature> = new Map();

  // Drawing area froms scratch
  let waypoints: Waypoint[] = [];
  let drawnShape: Feature<Polygon> | undefined;
  let drawnBoundary: GeneratedBoundaryFeature | null = null;

  let neighbourhoodBoundary: GeneratedBoundaryFeature | null = null;
  $: {
    if (addMode == "draw-area") {
      neighbourhoodBoundary = drawnBoundary;
    } else {
      neighbourhoodBoundary = selectedBoundary;
    }
  }

  $: {
    let newBoundary = null;
    if (drawnShape && drawnShape.geometry.coordinates[0].length > 3) {
      let featureCollection = {
        type: "FeatureCollection" as const,
        features: [drawnShape],
      };
      try {
        newBoundary = $backend!.generateMergedBoundary(featureCollection);
      } catch (error) {
        console.log(`error merging boundaries: ${error}`);
      }
    }
    drawnBoundary = newBoundary;
  }

  onMount(async () => {
    // Make sure the loading indicator has rendered before we generate boundaries.
    //
    // NOTE: I thought this is what `svelte.tick` was for, but it doesn't suffice.
    //     await tick();
    await new Promise((resolve) => {
      requestAnimationFrame(() => {
        // Waiting for one frame also doesn't seem to be enough, so we wait for two. *shrug*
        requestAnimationFrame(resolve);
      });
    });

    generatedBoundaries = $backend!.generatedBoundaries();
    loading = "";
  });

  function clickedBoundary(e: CustomEvent<LayerClickInfo>) {
    // Trust generateId to make IDs in order
    let featureId = e.detail.features[0].id as number;
    let feature: GeneratedBoundaryFeature =
      generatedBoundaries.features[featureId];

    let newBoundaries = new Map(selectedBoundaries);

    // toggle
    if (newBoundaries.has(featureId)) {
      newBoundaries.delete(featureId);
    } else {
      newBoundaries.set(featureId, feature);
    }

    if (newBoundaries.size === 0) {
      selectedBoundary = null;
      selectedBoundaries = newBoundaries;
    } else if (newBoundaries.size === 1) {
      selectedBoundary = newBoundaries.values().next().value!;
      selectedBoundaries = newBoundaries;
    } else {
      // Aggregate the selected boundaries
      let featureCollection = {
        type: "FeatureCollection" as const,
        features: Array.from(newBoundaries.values()),
      };
      try {
        selectedBoundary = $backend!.generateMergedBoundary(featureCollection);
        selectedBoundaries = newBoundaries;
      } catch (error) {
        console.log(`error merging boundaries: ${error}`);
        window.alert(
          `Sorry, the boundaries you selected cannot be merged.\nError: ${error}`,
        );
      }
    }
  }

  function createNeighbourhood(selectedBoundary: GeneratedBoundaryFeature) {
    let defaultName = $projectStorage.nextAvailableNeighbourhoodName(
      $currentProjectID!,
    );

    let name = pickNeighbourhoodName(
      $backend!,
      "What do you want to name the neighbourhood?",
      defaultName,
    );
    if (!name) {
      return;
    }
    try {
      const properties: GeoJSON.GeoJsonProperties = {};
      if (addMode == "draw-area" && drawnShape?.properties?.waypoints) {
        properties.waypoints = drawnShape.properties.waypoints;
      } else {
        // Omitted waypoints will be lazily filled out when the user tries to edit the boundary.
      }
      let feature = {
        type: "Feature" as const,
        properties,
        geometry: selectedBoundary.geometry,
      };
      $backend!.setNeighbourhoodBoundary(name, feature);
      saveCurrentProject();
      $backend!.setCurrentNeighbourhood(name);
      $mode = {
        mode: "neighbourhood",
      };
    } catch (err) {
      window.alert(`Sorry, this boundary is invalid: ${err}`);
    }
  }

  function download() {
    downloadGeneratedFile(
      "auto_boundaries.geojson",
      JSON.stringify(generatedBoundaries, null, "  "),
    );
  }

  function fillColor(
    selectedPrioritization: Prioritization,
  ): DataDrivenPropertyValueSpecification<string> {
    let noneColor = [
      "match",
      ["%", ["id"], 5],
      0,
      "blue",
      1,
      "yellow",
      2,
      "green",
      3,
      "purple",
      4,
      "orange",
      "black",
    ] as DataDrivenPropertyValueSpecification<string>;

    return prioritizationFillColor({ none: noneColor }, selectedPrioritization);
  }

  function fillOpacity(
    selectedPrioritization: Prioritization,
  ): DataDrivenPropertyValueSpecification<number> {
    return {
      none: hoverStateFilter(0.3, 0.5),
      area: hoverStateFilter(0.7, 0.9),
      car_ownership: hoverStateFilter(0.7, 0.9),
      density: hoverStateFilter(0.7, 0.9),
      pois: hoverStateFilter(0.7, 0.9),
      simd: hoverStateFilter(0.7, 0.9),
      stats19: hoverStateFilter(0.7, 0.9),
    }[selectedPrioritization];
  }

  function clearNeighbourhoodBoundary() {
    selectedBoundary = null;
    selectedBoundaries.clear();
    selectedBoundaries = selectedBoundaries;
    waypoints = [];
    drawnBoundary = null;
    neighbourhoodBoundary = null;
  }
</script>

<Loading {loading} />
<SplitComponent>
  <div slot="top">
    <nav aria-label="breadcrumb">
      <ul>
        <li>
          <ModeLink
            mode={{ mode: "title", firstLoad: false }}
            afterLink={zoomToDefault}
          />
        </li>
        <li>
          <ModeLink mode={{ mode: "pick-neighbourhood" }} />
        </li>
        <li>{pageTitle($mode.mode)}</li>
      </ul>
    </nav>
  </div>

  <div slot="sidebar">
    <BackButton mode={{ mode: "pick-neighbourhood" }} />
    {#if $appFocus == "cnt"}
      <h3>Prioritization</h3>
      <p>Compare metrics across candidate neighbourhoods.</p>
      <PrioritizationSelect bind:selectedPrioritization />
    {/if}

    {#if selectedPrioritization == "none"}
      <p>The colors are arbitrary, just to distinguish better.</p>
    {/if}

    <hr />

    <div>
      <div class="modes">
        <button
          on:click={() => (addMode = "choose-area")}
          class:active={addMode == "choose-area"}
          disabled={addMode == "choose-area"}
        >
          Choose area
        </button>
        <span style="margin: 0 16px;">or</span>
        <button
          on:click={() => (addMode = "draw-area")}
          class:active={addMode == "draw-area"}
          disabled={addMode == "draw-area"}
        >
          Draw area
        </button>
      </div>
      {#if addMode == "choose-area"}
        <div
          class="step"
          class:active={!neighbourhoodBoundary}
          class:complete={neighbourhoodBoundary}
        >
          <h3>1. Click an area to start your neighbourhood</h3>
          <p>
            These particular boundaries are suggested by finding roads,
            railways, and water that form severances.
          </p>
        </div>
        <div
          class="step"
          class:active={neighbourhoodBoundary}
          class:complete={selectedBoundaries.size > 1}
        >
          <h3>2. Include additional areas</h3>
          <p>Click any adjacent areas you'd like to add to your boundary.</p>
        </div>
      {:else if addMode == "draw-area"}
        <div
          class="step"
          class:active={!neighbourhoodBoundary}
          class:complete={neighbourhoodBoundary}
        >
          <h3>1. Draw your neighbourhood</h3>
        </div>
        <AreaControls
          map={notNull($map)}
          bind:waypoints
          bind:drawnShapeOut={drawnShape}
        />
        <div
          class="step"
          class:active={neighbourhoodBoundary}
          class:complete={selectedBoundaries.size > 1}
          style="margin-top: 16px;"
        >
          <h3>2. Refine your boundary</h3>
          <p>
            Continue to add, delete, and move points until you're happy with
            your neighbourhood boundary. Don't worry, you can always adjust the
            boundary more later.
          </p>
        </div>
      {/if}
      <div class="step" class:active={neighbourhoodBoundary}>
        <h3>3. Finished?</h3>
        <p>When you're done, click "Create".</p>
      </div>
      <div
        style="display: flex; gap: 16px; justify-content: space-between; margin-bottom: 16px;"
      >
        <button
          on:click={() => createNeighbourhood(notNull(neighbourhoodBoundary))}
          disabled={!neighbourhoodBoundary}
        >
          Create neighborhood
        </button>
        <button
          class="destructive"
          on:click={clearNeighbourhoodBoundary}
          style="display: flex; gap: 8px; align-items: center;"
          disabled={!(
            neighbourhoodBoundary ||
            (addMode == "draw-area" && waypoints.length > 0)
          )}
        >
          <Trash2 /> Start over
        </button>
      </div>
      <h3>Your neighbourhood overall</h3>
      <div class="neighbourhood-boundary-summary">
        {#if neighbourhoodBoundary}
          <NeighbourhoodBoundarySummary {neighbourhoodBoundary} />
        {:else}
          <span style="text-align:center;">
            {#if addMode == "choose-area"}
              Empty so far. Click an area to get started.
            {:else if addMode == "draw-area"}
              {#if waypoints.length < 3}
                Empty so far. Click the map to add points around your
                neighborhood to get started.
              {:else}
                Not a valid shape yet — try dragging the points into a box
                around your neighbourhood. Note the ordering of the points.
              {/if}
            {/if}
          </span>
        {/if}
      </div>
    </div>
    <hr />

    <button class="secondary" on:click={download}>Export to GeoJSON</button>
  </div>

  <div slot="map">
    {#if neighbourhoodBoundary}
      <GeoJSON
        data={{
          type: "FeatureCollection",
          features: [neighbourhoodBoundary],
        }}
      >
        <LineLayer
          {...layerId("neighbourhood-boundaries-selected-outline", false)}
          paint={{
            "line-color": "black",
            "line-width": 4,
            "line-dasharray": [2, 2],
          }}
        />
        <LineLayer
          {...layerId("neighbourhood-boundaries-selected-outline-base", false)}
          paint={{
            "line-color": "white",
            "line-width": 8,
            "line-opacity": 0.7,
          }}
        />
      </GeoJSON>
    {/if}
    {#if addMode == "choose-area"}
      <GeoJSON data={generatedBoundaries} generateId>
        <FillLayer
          {...layerId("neighbourhood-boundaries", false)}
          paint={{
            "fill-color": fillColor(selectedPrioritization),
            "fill-opacity": fillOpacity(selectedPrioritization),
          }}
          manageHoverState
          hoverCursor="pointer"
          on:click={clickedBoundary}
        >
          {#if selectedPrioritization != "simd"}
            <Popup openOn="hover" let:props>
              {#if selectedPrioritization == "none"}
                <b>Area:</b>
                {props.area_km2.toFixed(1)} km²
              {:else if selectedPrioritization == "car_ownership"}
                <b>Car or van ownership</b>
                <br />
                {prettyPrintPercent(
                  props.households_with_cars_or_vans,
                  props.total_households,
                )} of approximately {props.total_households.toLocaleString()}
                households have at least one car or van.
              {:else if selectedPrioritization == "density"}
                <b>Population density</b>
                <br />
                {Math.round(props.population / props.area_km2).toLocaleString()}
                people / km²
              {:else if selectedPrioritization == "stats19"}
                <b>Pedestrian and cyclist collisions</b>
                <br />
                {(props.number_stats19_collisions / props.area_km2).toFixed(1)} /
                km²
              {:else if selectedPrioritization == "pois"}
                <b>Points of interest</b>
                <br />
                {(props.number_pois / props.area_km2).toFixed(1)} / km²
              {/if}
            </Popup>
          {/if}
        </FillLayer>

        <LineLayer
          {...layerId("neighbourhood-boundaries-outline", false)}
          paint={{
            "line-color": "black",
            "line-width": 1,
          }}
        />
      </GeoJSON>
    {/if}
  </div>
</SplitComponent>

<style>
  .modes {
    margin-bottom: 8px;
  }
  .modes button.active {
    background-color: rgb(0, 116, 76);
    opacity: 1;
    color: white;
  }
  .modes button:not(.active):hover {
    background-color: rgba(0, 116, 76, 0.5);
  }
  .modes button {
    background-color: white;
    color: black;
    border: solid green 1px;
  }
  .neighbourhood-boundary-summary {
    border: dashed black 2px;
    border-radius: 8px;
    margin-bottom: 16px;
    padding: 16px;
  }
  .step h3::before {
    /* some content is necessary for the width to take effect. */
    content: " ";
    /* approximate width of widest emoji */
    width: 24px;
    display: inline-block;
    margin-right: 8px;
  }
  .step.active h3::before {
    content: "👉";
  }
  .step.complete h3::before {
    content: "✅";
  }
  .step:not(.active) {
    opacity: 0.5;
  }
</style>
