<script lang="ts">
  import { run } from 'svelte/legacy';

  import type { Feature, FeatureCollection, Polygon } from "geojson";
  import { Pencil, Pointer, Trash2 } from "lucide-svelte";
  import type { DataDrivenPropertyValueSpecification } from "maplibre-gl";
  import { onMount } from "svelte";
  import {
    FillLayer,
    GeoJSON,
    hoverStateFilter,
    LineLayer,
    Popup,
    type LayerClickInfo,
  } from "svelte-maplibre";
  import { downloadGeneratedFile } from "svelte-utils";
  import { emptyGeojson } from "svelte-utils/map";
  import { SplitComponent } from "svelte-utils/top_bar_layout";
  import BackButton from "./BackButton.svelte";
  import {
    layerId,
    Loading,
    ModeLink,
    pageTitle,
    prettyPrintPercent,
    refreshLoadingScreen,
  } from "./common";
  import AreaControls from "./common/draw_area/AreaControls.svelte";
  import { type Waypoint } from "./common/draw_area/stores";
  import NeighbourhoodBoundarySummary from "./common/NeighbourhoodBoundarySummary.svelte";
  import { pickNeighbourhoodName } from "./common/pick_names";
  import {
    prioritizationFillColor,
    PrioritizationSelect,
    type Prioritization,
  } from "./prioritization";
  import {
    appFocus,
    backend,
    currentNeighbourhoodName,
    currentProjectID,
    map,
    metricBuckets,
    mode,
    projectStorage,
    saveCurrentProject,
  } from "./stores";
  import type { GeneratedBoundaryFeature } from "./wasm";

  let loading = $state("Generating severance boundaries...");
  let generatedBoundaries: FeatureCollection<
    GeneratedBoundaryFeature["geometry"],
    GeneratedBoundaryFeature["properties"]
  > = $state(emptyGeojson() as any);

  let addMode: "choose-area" | "draw-area" = $state("choose-area");

  // Choosing area from autogenerated boundaries
  let selectedPrioritization: Prioritization =
    $state($appFocus == "cnt" ? "combined" : "none");
  let selectedBoundary: GeneratedBoundaryFeature | null = $state(null);
  let selectedBoundaries: Map<number, GeneratedBoundaryFeature> = $state(new Map());

  // Drawing area froms scratch
  let waypoints: Waypoint[] = $state([]);
  let drawnShape: Feature<Polygon> | undefined = $state();
  let drawnBoundary: GeneratedBoundaryFeature | null = $state(null);

  let neighbourhoodBoundary: GeneratedBoundaryFeature | null = $state(null);
  run(() => {
    if (addMode == "draw-area") {
      neighbourhoodBoundary = drawnBoundary;
    } else {
      neighbourhoodBoundary = selectedBoundary;
    }
  });

  run(() => {
    let newBoundary = null;
    if (drawnShape && drawnShape.geometry.coordinates[0].length > 3) {
      let featureCollection = {
        type: "FeatureCollection" as const,
        features: [drawnShape],
      };
      try {
        newBoundary = $backend!.generateMergedBoundary(featureCollection);
      } catch (error) {
        console.log(`error merging boundaries: ${error}`);
      }
    }
    drawnBoundary = newBoundary;
  });

  onMount(async () => {
    await refreshLoadingScreen();
    generatedBoundaries = $backend!.generatedBoundaries();
    loading = "";
  });

  function clickedBoundary(e: LayerClickInfo) {
    // Trust generateId to make IDs in order
    let featureId = e.features[0].id as number;
    let feature: GeneratedBoundaryFeature =
      generatedBoundaries.features[featureId];

    let newBoundaries = new Map(selectedBoundaries);

    // toggle
    if (newBoundaries.has(featureId)) {
      newBoundaries.delete(featureId);
    } else {
      newBoundaries.set(featureId, feature);
    }

    if (newBoundaries.size === 0) {
      selectedBoundary = null;
      selectedBoundaries = newBoundaries;
    } else if (newBoundaries.size === 1) {
      selectedBoundary = newBoundaries.values().next().value!;
      selectedBoundaries = newBoundaries;
    } else {
      // Aggregate the selected boundaries
      let featureCollection = {
        type: "FeatureCollection" as const,
        features: Array.from(newBoundaries.values()),
      };
      try {
        selectedBoundary = $backend!.generateMergedBoundary(featureCollection);
        selectedBoundaries = newBoundaries;
      } catch (error) {
        console.log(`error merging boundaries: ${error}`);
        window.alert(
          `Sorry, the boundaries you selected cannot be merged.\nError: ${error}`,
        );
      }
    }
  }

  function createNeighbourhood(selectedBoundary: GeneratedBoundaryFeature) {
    let defaultName = $projectStorage.nextAvailableNeighbourhoodName(
      $currentProjectID!,
    );

    let name = pickNeighbourhoodName(
      $backend!,
      "What do you want to name the neighbourhood?",
      defaultName,
    );
    if (!name) {
      return;
    }
    try {
      const properties: GeoJSON.GeoJsonProperties = {};
      if (addMode == "draw-area" && drawnShape?.properties?.waypoints) {
        properties.waypoints = drawnShape.properties.waypoints;
      } else {
        // Omitted waypoints will be lazily filled out when the user tries to edit the boundary.
      }
      let feature = {
        type: "Feature" as const,
        properties,
        geometry: selectedBoundary.geometry,
      };
      $backend!.setCurrentNeighbourhoodBoundary(name, feature);
      $currentNeighbourhoodName = name;
      saveCurrentProject();
      $mode = {
        mode: "neighbourhood",
      };
    } catch (err) {
      window.alert(`Sorry, this boundary is invalid: ${err}`);
    }
  }

  function download() {
    downloadGeneratedFile(
      "auto_boundaries.geojson",
      JSON.stringify(generatedBoundaries, null, "  "),
    );
  }

  function fillColor(
    selectedPrioritization: Prioritization,
  ): DataDrivenPropertyValueSpecification<string> {
    let noneColor = [
      "match",
      ["%", ["id"], 5],
      0,
      "blue",
      1,
      "yellow",
      2,
      "green",
      3,
      "purple",
      4,
      "orange",
      "black",
    ] as DataDrivenPropertyValueSpecification<string>;

    return prioritizationFillColor(
      { none: noneColor },
      selectedPrioritization,
      $metricBuckets,
    );
  }

  function fillOpacity(
    selectedPrioritization: Prioritization,
  ): DataDrivenPropertyValueSpecification<number> {
    return {
      none: hoverStateFilter(0.3, 0.5),
      area: hoverStateFilter(0.7, 0.9),
      car_ownership: hoverStateFilter(0.7, 0.9),
      population_density: hoverStateFilter(0.7, 0.9),
      pois: hoverStateFilter(0.7, 0.9),
      simd: hoverStateFilter(0.7, 0.9),
      stats19: hoverStateFilter(0.7, 0.9),
      combined: hoverStateFilter(0.7, 0.9),
    }[selectedPrioritization];
  }

  function clearNeighbourhoodBoundary() {
    selectedBoundary = null;
    selectedBoundaries.clear();
    selectedBoundaries = selectedBoundaries;
    waypoints = [];
    drawnBoundary = null;
    neighbourhoodBoundary = null;
  }

  function onKeyDown(e: KeyboardEvent) {
    if (e.key == "Enter" && neighbourhoodBoundary) {
      createNeighbourhood(neighbourhoodBoundary);
    }
  }
</script>

<svelte:window onkeydown={onKeyDown} />

<Loading {loading} />

<SplitComponent>
  {#snippet top()}
    <nav aria-label="breadcrumb">
      <ul>
        <li>
          <ModeLink mode={{ mode: "title" }} />
        </li>
        <li>
          <ModeLink mode={{ mode: "pick-neighbourhood" }} />
        </li>
        <li>{pageTitle($mode.mode)}</li>
      </ul>
    </nav>
  {/snippet}

  {#snippet left()}
    <BackButton mode={{ mode: "pick-neighbourhood" }} />
    {#if $appFocus == "cnt"}
      <h3>Prioritisation</h3>
      <p>
        Compare the prioritisation or individual metrics across candidate
        neighbourhoods.
      </p>
      <PrioritizationSelect bind:selectedPrioritization />
    {/if}

    {#if selectedPrioritization == "none"}
      <p>The colors are arbitrary, just to distinguish better.</p>
    {/if}

    <hr />

    <div>
      <div
        class="tool-palette"
        style="display: flex; align-items: center; gap: 16px;"
      >
        <button
          onclick={() => (addMode = "choose-area")}
          class:active={addMode == "choose-area"}
        >
          <Pointer />
          Choose area
        </button>
        or
        <button
          onclick={() => (addMode = "draw-area")}
          class:active={addMode == "draw-area"}
        >
          <Pencil />
          Draw area
        </button>
      </div>
      {#if addMode == "choose-area"}
        <div
          class="step"
          class:active={!neighbourhoodBoundary}
          class:complete={neighbourhoodBoundary}
        >
          <h3>1. Click an area to start your neighbourhood</h3>
          <p>
            These particular boundaries are suggested by finding roads,
            railways, and water that form severances.
          </p>
        </div>
        <div
          class="step"
          class:active={neighbourhoodBoundary}
          class:complete={selectedBoundaries.size > 1}
        >
          <h3>2. Include additional areas</h3>
          <p>Click any adjacent areas you'd like to add to your boundary.</p>
        </div>
      {:else if addMode == "draw-area"}
        <div
          class="step"
          class:active={!neighbourhoodBoundary}
          class:complete={neighbourhoodBoundary}
        >
          <h3>1. Draw your neighbourhood</h3>
        </div>
        <AreaControls
          map={$map!}
          bind:waypoints
          bind:drawnShapeOut={drawnShape}
        />
        <div
          class="step"
          class:active={neighbourhoodBoundary}
          class:complete={selectedBoundaries.size > 1}
          style="margin-top: 16px;"
        >
          <h3>2. Refine your boundary</h3>
          <p>
            Continue to add, delete, and move points until you're happy with
            your neighbourhood boundary. Don't worry, you can always adjust the
            boundary more later.
          </p>
        </div>
      {/if}
      <div class="step" class:active={neighbourhoodBoundary}>
        <h3>3. Finished?</h3>
        <p>When you're done, click "Create".</p>
      </div>
      <div
        style="display: flex; gap: 16px; justify-content: space-between; margin-bottom: 16px;"
      >
        <button
          onclick={() => createNeighbourhood(neighbourhoodBoundary!)}
          disabled={!neighbourhoodBoundary}
        >
          Create neighborhood
        </button>
        <button
          class="destructive"
          onclick={clearNeighbourhoodBoundary}
          style="display: flex; gap: 8px; align-items: center;"
          disabled={!(
            neighbourhoodBoundary ||
            (addMode == "draw-area" && waypoints.length > 0)
          )}
        >
          <Trash2 /> Start over
        </button>
      </div>
      <h3>Your neighbourhood overall</h3>
      <div class="neighbourhood-boundary-summary">
        {#if neighbourhoodBoundary}
          <NeighbourhoodBoundarySummary {neighbourhoodBoundary} />
        {:else}
          <span style="text-align:center;">
            {#if addMode == "choose-area"}
              Empty so far. Click a colored area to get started.
            {:else if addMode == "draw-area"}
              {#if waypoints.length < 3}
                Empty so far. Click the map to add points around your
                neighborhood to get started.
              {:else}
                Not a valid shape yet â€” try dragging the points into a box
                around your neighbourhood. Note the ordering of the points.
              {/if}
            {/if}
          </span>
        {/if}
      </div>
    </div>
    <hr />

    <button class="secondary" onclick={download}
      >Export metrics to GeoJSON</button
    >
  {/snippet}

  {#snippet main()}
    {#if neighbourhoodBoundary}
      <GeoJSON
        data={{
          type: "FeatureCollection",
          features: [neighbourhoodBoundary],
        }}
      >
        <LineLayer
          {...layerId("neighbourhood-boundaries-selected-outline", false)}
          paint={{
            "line-color": "black",
            "line-width": 4,
            "line-dasharray": [2, 2],
          }}
        />
        <LineLayer
          {...layerId("neighbourhood-boundaries-selected-outline-base", false)}
          paint={{
            "line-color": "white",
            "line-width": 8,
          }}
        />
      </GeoJSON>
    {/if}
    {#if addMode == "choose-area"}
      <GeoJSON data={generatedBoundaries} generateId>
        <FillLayer
          {...layerId("neighbourhood-boundaries", false)}
          paint={{
            "fill-color": fillColor(selectedPrioritization),
            "fill-opacity": fillOpacity(selectedPrioritization),
          }}
          manageHoverState
          hoverCursor="pointer"
          onclick={clickedBoundary}
        >
          {#if selectedPrioritization != "simd"}
            <Popup openOn="hover">
              {#snippet children({ data })}
                {@const props = data!.properties!}
                {#if selectedPrioritization == "none" || selectedPrioritization == "area"}
                  <b>Area:</b>
                  {props.area_km2.toFixed(1)} kmÂ²
                {:else if selectedPrioritization == "car_ownership"}
                  <b>Car or van ownership</b>
                  <br />
                  {prettyPrintPercent(
                    props.households_with_cars_or_vans,
                    props.total_households,
                  )} of approximately {props.total_households.toLocaleString()}
                  households have at least one car or van.
                {:else if selectedPrioritization == "population_density"}
                  <b>Population density</b>
                  <br />
                  {Math.round(
                    props.population / props.area_km2,
                  ).toLocaleString()}
                  people / kmÂ²
                {:else if selectedPrioritization == "stats19"}
                  <b>Pedestrian and cyclist collisions</b>
                  <br />
                  {(props.number_stats19_collisions / props.area_km2).toFixed(
                    1,
                  )} / kmÂ²
                {:else if selectedPrioritization == "pois"}
                  <b>Points of interest</b>
                  <br />
                  {(props.number_pois / props.area_km2).toFixed(1)} / kmÂ²
                {:else if selectedPrioritization == "combined"}
                  <b>Combined score</b>
                  <br />
                  {props.combined_score}
                {/if}
              {/snippet}
            </Popup>
          {/if}
        </FillLayer>

        <LineLayer
          {...layerId("neighbourhood-boundaries-outline", false)}
          paint={{
            "line-color": "black",
            "line-width": 1,
          }}
        />
      </GeoJSON>
    {/if}
  {/snippet}
</SplitComponent>

<style>
  .tool-palette {
    margin-bottom: 16px;
  }
  .neighbourhood-boundary-summary {
    border: dashed black 2px;
    border-radius: 8px;
    margin-bottom: 16px;
    padding: 16px;
  }
  .step h3::before {
    /* some content is necessary for the width to take effect. */
    content: " ";
    /* approximate width of widest emoji */
    width: 24px;
    display: inline-block;
    margin-right: 8px;
  }
  .step.active h3::before {
    content: "ðŸ‘‰";
  }
  .step.complete h3::before {
    content: "âœ…";
  }
  .step:not(.active) {
    opacity: 0.5;
  }
</style>
