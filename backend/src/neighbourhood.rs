use std::collections::BTreeSet;

use crate::geo_helpers::{
    buffer_polygon, euclidean_bearing, invert_feature_geometry_in_place, make_polygon_valid,
};
use anyhow::Result;
use geo::{
    BooleanOps, Coord, CoordNum, Euclidean, Length, LineString, MapCoordsInPlace, MultiLineString,
    Point, Polygon, Simplify,
};
use geojson::{Feature, FeatureCollection};
use rstar::{primitives::GeomWithData, RTree};
use serde::{Deserialize, Serialize};
use utils::{aabb, buffer_aabb, Mercator};
use web_time::Instant;

use crate::boundary_stats::{BoundaryStats, PreparedContextData};
use crate::map_model::DiagonalFilter;
use crate::render_cells::Color;
use crate::route::RouterInput;
use crate::{
    Cell, Intersection, IntersectionID, MapModel, ModalFilter, RenderCells, Road, RoadID,
    Shortcuts, TravelFlow,
};

/// The static data that defines where exactly a neighbourhood is.
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct NeighbourhoodDefinition {
    /// `geometry` is always Mercator.
    /// We convert it to/from wgs84 only when serializizing/deserializing GeoJSON.
    #[serde(
        serialize_with = "geojson::ser::serialize_geometry",
        deserialize_with = "geojson::de::deserialize_geometry"
    )]
    pub geometry: Polygon,
    pub name: String,

    // Autogenerated boundaries have no waypoints
    pub waypoints: Option<Vec<WayPoint>>,
}

/// Used when hand-drawing a neighbourhood boundary. We save this in case the user wants to
/// edit the boundary later
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct WayPoint {
    lat: f64,
    lon: f64,
    snapped: bool,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct WayPoints(Vec<WayPoint>);
impl MapCoordsInPlace<f64> for WayPoints {
    fn map_coords_in_place(&mut self, func: impl Fn(Coord<f64>) -> Coord<f64> + Copy)
    where
        f64: CoordNum,
    {
        for waypoint in self.0.iter_mut() {
            let coord = Coord {
                x: waypoint.lon,
                y: waypoint.lat,
            };
            let new_coord = func(coord);
            waypoint.lon = new_coord.x;
            waypoint.lat = new_coord.y;
        }
    }

    fn try_map_coords_in_place<E>(
        &mut self,
        func: impl Fn(Coord<f64>) -> std::result::Result<Coord<f64>, E>,
    ) -> std::result::Result<(), E>
    where
        f64: CoordNum,
    {
        for waypoint in self.0.iter_mut() {
            let coord = Coord {
                x: waypoint.lon,
                y: waypoint.lat,
            };
            let new_coord = func(coord)?;
            waypoint.lon = new_coord.x;
            waypoint.lat = new_coord.y;
        }
        Ok(())
    }
}

impl WayPoint {
    pub fn waypoints_for_ring(ring: &LineString) -> WayPoints {
        let simplified = ring.simplify(5.0);

        // ring is closed, so skip the first point, which is redundant with the last
        let coords_iter = simplified.0.iter().skip(1);

        WayPoints(
            coords_iter
                .map(|coord| WayPoint {
                    lat: coord.y,
                    lon: coord.x,
                    snapped: false,
                })
                .collect(),
        )
    }
}

/// Includes data derived from the neighborhoods definition.
///
/// This data isn't saved.
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct NeighbourhoodBoundary {
    #[serde(flatten)]
    pub definition: NeighbourhoodDefinition,
    #[serde(flatten)]
    pub boundary_stats: BoundaryStats,
}

/// Neighbourhood road network
pub struct Neighbourhood {
    // Immutable once created
    pub interior_roads: BTreeSet<RoadID>,
    // Immutable once created
    pub main_roads: BTreeSet<RoadID>,
    pub editable_intersections: BTreeSet<IntersectionID>,
    pub border_intersections: BTreeSet<IntersectionID>,
    pub boundary: NeighbourhoodBoundary,
    // Updated after mutations
    pub derived: Option<DerivedNeighbourhoodState>,
}

pub struct DerivedNeighbourhoodState {
    render_cells: RenderCells,
    pub shortcuts: Shortcuts,
}

impl NeighbourhoodDefinition {
    pub fn to_feature(&self, map: &MapModel) -> Feature {
        let mut projected = self.clone();
        map.mercator.to_wgs84_in_place(&mut projected.geometry);
        let mut feature =
            geojson::ser::to_feature(projected).expect("should have no unserializable fields");
        let props = feature
            .properties
            .as_mut()
            .expect("NeighbourhoodDefinition always has properties");
        props.insert("kind".to_string(), "boundary".into());
        feature
    }

    pub fn from_feature(feature: Feature, map: &MapModel) -> Result<Self> {
        let mut neighbourhood_definition: Self = geojson::de::from_feature(feature)?;
        map.mercator
            .to_mercator_in_place(&mut neighbourhood_definition.geometry);
        neighbourhood_definition.geometry = make_polygon_valid(&neighbourhood_definition.geometry)?;
        Ok(neighbourhood_definition)
    }
}

impl NeighbourhoodBoundary {
    pub fn new(
        definition: NeighbourhoodDefinition,
        context_data: Option<&PreparedContextData>,
    ) -> Self {
        let boundary_stats = BoundaryStats::new(&definition.geometry, context_data);
        Self {
            definition,
            boundary_stats,
        }
    }
    pub fn geometry(&self) -> &Polygon {
        &self.definition.geometry
    }
    pub fn name(&self) -> &str {
        &self.definition.name
    }
    pub fn to_feature(&self, map: &MapModel) -> Feature {
        let mut projected = self.clone();
        map.mercator
            .to_wgs84_in_place(&mut projected.definition.geometry);
        let mut feature =
            geojson::ser::to_feature(projected).expect("should have no unserializable fields");
        let props = feature
            .properties
            .as_mut()
            .expect("NeighbourhoodStats always has properties");
        props.insert("kind".to_string(), "boundary".into());
        feature
    }
}

impl Neighbourhood {
    pub fn new(map: &MapModel, boundary: NeighbourhoodBoundary) -> Result<Self> {
        let t1 = Instant::now();

        let mut interior_roads = BTreeSet::new();
        let mut main_roads = BTreeSet::new();
        debug!(
            "boundary_polygon: {boundary_polygon:?}",
            boundary_polygon = boundary.geometry()
        );
        // Buffer just a bit to account for floating point precision - if we buffer too much
        // we'll inadvertenly include roads beyond the boundary.
        let bbox = buffer_aabb(aabb(boundary.geometry()), 1.0);
        let buffered_boundary = buffer_polygon(boundary.geometry(), 1.0)?;
        for obj in map.closest_road.locate_in_envelope_intersecting(&bbox) {
            let road = &map.roads[obj.data.0];
            if !is_road_mostly_inside(&road.linestring, &buffered_boundary) {
                continue;
            }

            if map.is_main_road[&road.id] {
                main_roads.insert(road.id);
            } else {
                interior_roads.insert(road.id);
            }
        }

        let t2 = Instant::now();
        let mut editable_intersections = BTreeSet::new();
        let mut border_intersections = BTreeSet::new();
        for obj in map
            .closest_intersection
            .locate_in_envelope_intersecting(&bbox)
        {
            let intersection = map.get_i(obj.data);
            let mut interior_connections = 0;
            let mut main_road_connections = 0;

            for road_id in &intersection.roads {
                if main_roads.contains(road_id) {
                    main_road_connections += 1;
                } else if interior_roads.contains(road_id) {
                    interior_connections += 1;
                }
            }

            if interior_connections == 4 && main_road_connections == 0 {
                // only 4-way interior intersections are eligible for diagonal intersections
                editable_intersections.insert(intersection.id);
            } else if interior_connections > 0 && main_road_connections > 0 {
                // border intersections represent an "input" of traffic into the neighbourhood.
                // so it must be connected to both main and interior roads
                border_intersections.insert(intersection.id);
            }
        }

        if interior_roads.is_empty() {
            bail!("No roads inside the boundary");
        }

        let t3 = Instant::now();

        if true {
            info!("Neighbourhood set up, total {:?}. Finding roads took {:?}, intersections took {:?}", t3 - t1, t2 - t1, t3 - t2);
        }

        let mut n = Self {
            interior_roads,
            main_roads,
            boundary,
            editable_intersections,
            border_intersections,
            derived: None,
        };
        n.after_edit(map);
        Ok(n)
    }

    pub fn after_edit(&mut self, map: &MapModel) {
        let t1 = Instant::now();
        let cells = Cell::find_all(map, self);
        let t2 = Instant::now();
        let render_cells = RenderCells::new(map, self, &cells);
        let t3 = Instant::now();
        let shortcuts = Shortcuts::new(map, self, &cells);
        let t4 = Instant::now();
        self.derived = Some(DerivedNeighbourhoodState {
            render_cells,
            shortcuts,
        });
        if true {
            info!("Neighbourhood edited, total {:?}. Finding cells took {:?}, rendering cells took {:?}, finding shortcuts took {:?}", t4 - t1, t2 - t1, t3 - t2, t4 - t3);
        }
    }

    pub fn boundary_polygon(&self) -> &Polygon {
        &self.boundary.geometry()
    }

    pub fn name(&self) -> &str {
        &self.boundary.name()
    }

    pub fn editable_roads(&self) -> Vec<RoadID> {
        self.interior_roads
            .iter()
            .chain(self.main_roads.iter())
            .cloned()
            .collect()
    }

    pub fn shortcuts_router_input_before<'a>(&'a self, map: &'a MapModel) -> impl RouterInput + 'a {
        NeighbourhoodShortcutsRouterInput {
            map: &map,
            neighbourhood: &self,
            before: true,
        }
    }

    pub fn shortcuts_router_input_after<'a>(&'a self, map: &'a MapModel) -> impl RouterInput + 'a {
        NeighbourhoodShortcutsRouterInput {
            map: &map,
            neighbourhood: &self,
            before: false,
        }
    }

    pub fn to_gj(&self, map: &MapModel) -> FeatureCollection {
        let mut features = Vec::new();

        let derived = self.derived.as_ref().unwrap();

        // Create a neighbourhood "mask" to highlight the editable neighbourhood
        {
            let mut neighbourhood_mask = self.boundary.clone();
            neighbourhood_mask.definition.geometry = buffer_polygon(self.boundary.geometry(), 10.0)
                .expect("valid neighbourhood buffering");
            let mut boundary_feature = neighbourhood_mask.to_feature(map);
            invert_feature_geometry_in_place(&mut boundary_feature);
            features.push(boundary_feature);
        }

        for r in &self.main_roads {
            let road = map.get_r(*r);
            let mut f = road.to_gj(&map.mercator);
            f.set_property("kind", "main_road");
            f.set_property("travel_flow", map.travel_flows[&r].to_string());
            f.set_property(
                "travel_flow_edited",
                map.travel_flows[&r] != TravelFlow::from_osm(&road.tags),
            );
            f.set_property(
                "edited",
                map.travel_flows[&r] != TravelFlow::from_osm(&road.tags)
                    || map.modal_filters.get(&r) != map.original_modal_filters.get(&r),
            );
            f.set_property("road", r.0);
            if let Some(color) = derived.render_cells.colors_per_road.get(&r) {
                f.set_property("cell_color", *color);
            }
            features.push(f)
        }
        for r in &self.interior_roads {
            let road = map.get_r(*r);
            let mut f = road.to_gj(&map.mercator);
            f.set_property("kind", "interior_road");
            f.set_property(
                "shortcuts",
                derived
                    .shortcuts
                    .count_per_road
                    .get(&r)
                    .cloned()
                    .unwrap_or(0),
            );
            f.set_property("travel_flow", map.travel_flows[&r].to_string());
            f.set_property(
                "travel_flow_edited",
                map.travel_flows[&r] != TravelFlow::from_osm(&road.tags),
            );
            f.set_property(
                "edited",
                map.travel_flows[&r] != TravelFlow::from_osm(&road.tags)
                    || map.modal_filters.get(&r) != map.original_modal_filters.get(&r),
            );
            f.set_property("road", r.0);
            if let Some(color) = derived.render_cells.colors_per_road.get(&r) {
                f.set_property("cell_color", *color);
            }
            f.set_property(
                "road_kind",
                if road.tags.is("access", "private") {
                    "private"
                } else if road.tags.is("highway", "pedestrian") {
                    "pedestrian"
                } else if road.tags.is("highway", "service") {
                    "service"
                } else {
                    "normal"
                },
            );

            features.push(f);
        }

        for intersection_id in &self.editable_intersections {
            let intersection = map.get_i(*intersection_id);
            let mut f = map.mercator.to_wgs84_gj(&intersection.point);
            f.set_property("kind", "editable_intersection");
            f.set_property("intersection_id", intersection_id.0);
            let filter = map.diagonal_filters.get(intersection_id);
            f.set_property("filter", filter);
            features.push(f);
        }

        for i in &self.border_intersections {
            for border_entry in self.border_entries(*i, map) {
                features.push(border_entry.to_feature(&map.mercator))
            }
        }

        for (polygons, color) in derived
            .render_cells
            .polygons_per_cell
            .iter()
            .zip(derived.render_cells.colors.iter())
        {
            let mut f = map.mercator.to_wgs84_gj(polygons);
            f.set_property("kind", "cell");
            f.set_property("cell_color", *color);
            features.push(f);
        }

        FeatureCollection {
            features,
            bbox: None,
            foreign_members: Some(
                // The features are items within the neighbourhood.
                // The foreign members are properties of the *entire* neighborhood.
                serde_json::json!({
                    "undo_length": map.undo_stack.len(),
                    "redo_length": map.redo_stack.len(),
                })
                .as_object()
                .unwrap()
                .clone(),
            ),
        }
    }

    fn border_entries<'a>(
        &'a self,
        i: IntersectionID,
        map: &'a MapModel,
    ) -> impl Iterator<Item = BorderEntry> + 'a {
        let derived = self.derived.as_ref().unwrap();
        let intersection = map.get_i(i);
        intersection.roads.iter().filter_map(move |r| {
            // Most borders only have one road in the interior of the neighbourhood. Draw an arrow
            // for each of those. If there happen to be multiple interior roads for one border, the
            // arrows will overlap each other -- but that happens anyway with borders close
            // together at certain angles.
            if !self.interior_roads.contains(r) {
                return None;
            }

            // Design choice: when we have a filter right at the entrance of a neighbourhood, it
            // creates its own little cell allowing access to just the very beginning of the
            // road. Let's not draw anything for that.
            if map.modal_filters.contains_key(r) {
                return None;
            }

            // If the cell is unimportant (only service roads), also skip the arrow.
            if derived.render_cells.unimportant_roads.contains(r) {
                return None;
            }

            // Find the angle pointing into the neighbourhood
            let road = map.get_r(*r);
            let bearing_upon_entry = if road.src_i == i {
                let entry = road
                    .linestring
                    .lines()
                    .next()
                    .expect("non-empty roads only");
                euclidean_bearing(entry.start, entry.end)
            } else {
                let entry = road
                    .linestring
                    .lines()
                    .last()
                    .expect("non-empty roads only");
                euclidean_bearing(entry.end, entry.start)
            };
            let cell_color = derived.render_cells.colors_per_border[&i];
            Some(BorderEntry {
                geometry: intersection.point,
                bearing_upon_entry,
                cell_color,
            })
        })
    }
}

fn is_road_mostly_inside(line_string: &LineString, polygon: &Polygon) -> bool {
    let invert = false;
    let clipped = polygon.clip(&MultiLineString(vec![line_string.clone()]), invert);
    let ratio_inside = Euclidean.length(&clipped) / Euclidean.length(line_string);
    ratio_inside > 0.99
}

#[derive(Clone, Debug, Serialize)]
struct BorderEntry {
    #[serde(serialize_with = "geojson::ser::serialize_geometry")]
    geometry: Point,
    cell_color: Color,
    bearing_upon_entry: f64,
}

struct NeighbourhoodShortcutsRouterInput<'a> {
    pub(crate) map: &'a MapModel,
    pub(crate) neighbourhood: &'a Neighbourhood,
    before: bool,
}

impl RouterInput for NeighbourhoodShortcutsRouterInput<'_> {
    fn roads_iter(&self) -> impl Iterator<Item = &Road> {
        self.neighbourhood
            .interior_roads
            .iter()
            .chain(self.neighbourhood.main_roads.iter())
            .map(|r| self.map.get_r(*r))
    }
    fn closest_road(&self) -> &RTree<GeomWithData<LineString, RoadID>> {
        &self.map.closest_road
    }

    fn get_r(&self, r: RoadID) -> &Road {
        self.map.get_r(r)
    }

    fn get_i(&self, i: IntersectionID) -> &Intersection {
        self.map.get_i(i)
    }

    fn modal_filter(&self, r: RoadID) -> Option<&ModalFilter> {
        if self.before {
            self.map.original_modal_filters.get(&r)
        } else {
            self.map.modal_filters.get(&r)
        }
    }

    fn travel_flow(&self, r: RoadID) -> TravelFlow {
        if self.before {
            TravelFlow::from_osm(&self.get_r(r).tags)
        } else {
            self.map.travel_flows[&r]
        }
    }

    fn diagonal_filter(&self, r: IntersectionID) -> Option<&DiagonalFilter> {
        if self.before {
            None
        } else {
            self.map.diagonal_filters.get(&r)
        }
    }

    fn turn_restrictions(&self, i: IntersectionID) -> &Vec<(RoadID, RoadID)> {
        if self.before {
            &self.map.original_turn_restrictions[i.0]
        } else {
            &self.map.turn_restrictions[i.0]
        }
    }
}

impl BorderEntry {
    fn to_feature(&self, mercator: &Mercator) -> Feature {
        let mut projected = self.clone();
        mercator.to_wgs84_in_place(&mut projected.geometry);
        let mut feature =
            geojson::ser::to_feature(projected).expect("should have no unserializable fields");
        let props = feature
            .properties
            .as_mut()
            .expect("BorderEntry always has properties");
        props.insert("kind".to_string(), "border_entry".into());
        feature
    }
}
